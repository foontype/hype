#!/bin/bash

set -euo pipefail

HYPE_VERSION="0.5.2"
HYPEFILE="${HYPEFILE:-hypefile.yaml}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Debug and trace modes
DEBUG="${DEBUG:-false}"
TRACE="${TRACE:-false}"

# Enable trace mode if requested
if [[ "$TRACE" == "true" ]]; then
    set -x
fi

debug() {
    if [[ "$DEBUG" == "true" ]]; then
        echo -e "${BLUE}[DEBUG]${NC} $*" >&2
    fi
}

info() {
    echo -e "${GREEN}[INFO]${NC} $*"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $*"
}

error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

die() {
    error "$@"
    exit 1
}

# Check if required tools are available
check_dependencies() {
    local missing=()
    
    if ! command -v kubectl >/dev/null 2>&1; then
        missing+=("kubectl")
    fi
    
    if ! command -v helmfile >/dev/null 2>&1; then
        missing+=("helmfile")
    fi
    
    # Check for correct yq version (mikefarah/yq)
    if ! command -v yq >/dev/null 2>&1; then
        missing+=("yq")
    elif ! yq --version 2>&1 | grep -q "mikefarah"; then
        error "Wrong yq version detected. Please install mikefarah/yq"
        missing+=("yq (mikefarah version)")
    fi
    
    # Check for helm diff plugin
    if ! helm plugin list | grep -q "diff"; then
        missing+=("helm-diff plugin")
    fi
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        die "Missing required dependencies: ${missing[*]}"
    fi
}

# Show help
show_help() {
    cat <<EOF
HYPE CLI - Helmfile Wrapper Tool for Kubernetes AI Deployments

Usage:
  hype <hype-name> init                                          Create default resources
  hype <hype-name> deinit                                        Delete default resources  
  hype <hype-name> check                                         List default resources status
  hype <hype-name> template                                      Show rendered hype section YAML
  hype <hype-name> template state-values <configmap-name>        Show state-values file content
  hype <hype-name> parse section <hype|helmfile|taskfile>       Show raw section without headers
  hype <hype-name> trait                                         Show current trait
  hype <hype-name> trait set <trait-type>                       Set trait type
  hype <hype-name> trait unset                                   Remove trait
  hype <hype-name> task <task-name> [args...]                   Run task from taskfile section
  hype <hype-name> helmfile <helmfile-options>                  Run helmfile command
  hype upgrade                                                   Upgrade HYPE CLI to latest version
  hype --version                                                 Show version
  hype --help                                                    Show this help

Options:
  --version                Show version information
  --help                   Show help information

Environment Variables:
  HYPEFILE                 Path to hypefile.yaml (default: hypefile.yaml)
  DEBUG                    Enable debug output (default: false)
  TRACE                    Enable bash trace mode with set -x (default: false)

Task Variables (auto-set when running tasks):
  HYPE_NAME                Hype name passed to tasks
  HYPE_TRAIT               Current trait value (if set)
  HYPE_CURRENT_DIRECTORY   Current working directory

Examples:
  hype my-nginx init                                             Create resources for my-nginx
  hype my-nginx template                                         Show rendered YAML for my-nginx
  hype my-nginx template state-values my-nginx-state-values      Show state-values content
  hype my-nginx parse section hype                              Show raw hype section
  hype my-nginx parse section helmfile                          Show raw helmfile section
  hype my-nginx parse section taskfile                          Show raw taskfile section
  hype my-nginx trait                                            Show current trait for my-nginx
  hype my-nginx trait set web-server                            Set web-server trait for my-nginx
  hype my-nginx trait unset                                      Remove trait for my-nginx
  hype my-nginx task build                                       Run build task for my-nginx
  hype my-nginx task deploy --dry-run                           Run deploy task with arguments
  hype my-nginx helmfile apply                                   Apply helmfile for my-nginx
  hype my-nginx check                                            Check resource status
  hype my-nginx deinit                                           Remove all resources
  hype upgrade                                                   Upgrade to latest HYPE CLI version

EOF
}

# Show version
show_version() {
    echo "HYPE CLI version $HYPE_VERSION"
}

# Parse hypefile.yaml and split into hype, helmfile, and taskfile sections
parse_hypefile() {
    local hype_name="$1"
    
    if [[ ! -f "$HYPEFILE" ]]; then
        die "Hypefile not found: $HYPEFILE"
    fi
    
    debug "Parsing hypefile: $HYPEFILE"
    
    # Create temporary files
    HYPE_SECTION_FILE=$(mktemp)
    HELMFILE_SECTION_FILE=$(mktemp --suffix=.yaml.gotmpl)
    TASKFILE_SECTION_FILE=$(mktemp --suffix=.yaml)
    
    # Split file on "---" separator (supports up to 3 sections)
    awk -v hype_file="$HYPE_SECTION_FILE" -v helmfile_file="$HELMFILE_SECTION_FILE" -v taskfile_file="$TASKFILE_SECTION_FILE" '
    BEGIN { section = "hype"; section_count = 0 }
    /^---$/ { 
        section_count++
        if (section_count == 1) section = "helmfile"
        else if (section_count == 2) section = "taskfile"
        next 
    }
    section == "hype" { print > hype_file }
    section == "helmfile" { print > helmfile_file }
    section == "taskfile" { print > taskfile_file }
    ' "$HYPEFILE"
    
    # Replace template variables with actual values (hype section only)
    sed -i "s/{{ \.Hype\.Name }}/$hype_name/g" "$HYPE_SECTION_FILE"
    sed -i "s|{{ \.Hype\.CurrentDirectory }}|$(pwd)|g" "$HYPE_SECTION_FILE"
    
    # Replace {{ .Hype.Trait }} with actual trait value (hype section only)
    local trait_value
    if trait_value=$(get_hype_trait "$hype_name" 2>/dev/null); then
        debug "Found trait for template replacement: $trait_value"
        sed -i "s/{{ \.Hype\.Trait }}/$trait_value/g" "$HYPE_SECTION_FILE"
    else
        debug "No trait found, removing trait template variables"
        sed -i "s/{{ \.Hype\.Trait }}//g" "$HYPE_SECTION_FILE"
    fi
    
    # Note: TASKFILE_SECTION_FILE is not processed here - it keeps its original template variables
    # for go-task to process with environment variables
    
    debug "Created temporary files: $HYPE_SECTION_FILE, $HELMFILE_SECTION_FILE, $TASKFILE_SECTION_FILE"
    
    # Debug: Show contents of temporary files
    if [[ "$DEBUG" == "true" ]]; then
        debug "=== HYPE SECTION CONTENT ==="
        cat "$HYPE_SECTION_FILE" >&2
        debug "=== END HYPE SECTION ==="
        
        debug "=== HELMFILE SECTION CONTENT ==="
        cat "$HELMFILE_SECTION_FILE" >&2
        debug "=== END HELMFILE SECTION ==="
        
        debug "=== TASKFILE SECTION CONTENT ==="
        cat "$TASKFILE_SECTION_FILE" >&2
        debug "=== END TASKFILE SECTION ==="
    fi
}

# Cleanup temporary files
cleanup() {
    if [[ -n "${HYPE_SECTION_FILE:-}" && -f "$HYPE_SECTION_FILE" ]]; then
        rm -f "$HYPE_SECTION_FILE"
    fi
    if [[ -n "${HELMFILE_SECTION_FILE:-}" && -f "$HELMFILE_SECTION_FILE" ]]; then
        rm -f "$HELMFILE_SECTION_FILE"
    fi
    if [[ -n "${TASKFILE_SECTION_FILE:-}" && -f "$TASKFILE_SECTION_FILE" ]]; then
        rm -f "$TASKFILE_SECTION_FILE"
    fi
}

trap cleanup EXIT

# Get default resources from hype section
get_default_resources() {
    if [[ ! -f "$HYPE_SECTION_FILE" ]]; then
        return
    fi
    
    yq eval '.defaultResources[]' "$HYPE_SECTION_FILE" 2>/dev/null || true
}

# Validate state value configmap
validate_state_values_configmap() {
    local hype_name="$1"
    local configmap_name="$2"
    
    debug "Validating StateValuesConfigmap: $configmap_name for hype: $hype_name"
    
    # Parse hypefile first
    parse_hypefile "$hype_name"
    
    if [[ ! -f "$HYPE_SECTION_FILE" ]]; then
        error "No hype section found in hypefile"
        return 1
    fi
    
    # Get resource count and validate
    local resource_count
    resource_count=$(yq eval '.defaultResources | length' "$HYPE_SECTION_FILE" 2>/dev/null || echo "0")
    
    if [[ "$resource_count" -eq 0 ]]; then
        error "No default resources found in hypefile"
        return 1
    fi
    
    # Check if configmap exists in defaultResources and is StateValuesConfigmap type
    local found=false
    for (( i=0; i<resource_count; i++ )); do
        local name type
        
        name=$(yq eval ".defaultResources[$i].name" "$HYPE_SECTION_FILE" | sed "s/{{ \.Hype\.Name }}/$hype_name/g" | sed "s|{{ \.Hype\.CurrentDirectory }}|$(pwd)|g")
        type=$(yq eval ".defaultResources[$i].type" "$HYPE_SECTION_FILE")
        
        debug "Checking resource $i: name=$name, type=$type"
        
        if [[ "$name" == "$configmap_name" ]]; then
            found=true
            if [[ "$type" != "StateValuesConfigmap" ]]; then
                error "ConfigMap $configmap_name is not a StateValuesConfigmap (type: $type)"
                return 1
            fi
            break
        fi
    done
    
    if [[ "$found" != "true" ]]; then
        error "ConfigMap $configmap_name not found in hypefile defaultResources"
        return 1
    fi
    
    # Check if configmap exists in Kubernetes cluster
    if ! kubectl get configmap "$configmap_name" >/dev/null 2>&1; then
        error "ConfigMap $configmap_name does not exist in Kubernetes cluster"
        error "Run 'hype $hype_name init' first to create default resources"
        return 1
    fi
    
    debug "StateValuesConfigmap validation successful: $configmap_name"
    return 0
}

# Create kubernetes resource
create_resource() {
    local name="$1"
    local type="$2"
    local values_yaml="$3"
    local tmpdir
    
    debug "Creating resource: $name (type: $type)"
    
    # Create temporary directory for complex values
    tmpdir=$(mktemp -d)
    # shellcheck disable=SC2064
    trap "rm -rf '$tmpdir'" EXIT
    
    case "$type" in
        "DefaultStateValues")
            debug "DefaultStateValues detected - skipping resource creation (local processing only)"
            return
            ;;
        "StateValuesConfigmap"|"Configmap")
            if kubectl get configmap "$name" >/dev/null 2>&1; then
                info "ConfigMap $name already exists"
                return
            fi
            
            # Create configmap from values using new logic
            local kubectl_args=("create" "configmap" "$name")
            while IFS= read -r arg; do
                [[ -n "$arg" ]] && kubectl_args+=("$arg")
            done < <(get_resource_values "$values_yaml" "$tmpdir" "$type")
            
            kubectl "${kubectl_args[@]}"
            info "Created ConfigMap: $name"
            ;;
        "Secrets")
            if kubectl get secret "$name" >/dev/null 2>&1; then
                info "Secret $name already exists"
                return
            fi
            
            # Create secret from values using new logic
            local kubectl_args=("create" "secret" "generic" "$name")
            while IFS= read -r arg; do
                [[ -n "$arg" ]] && kubectl_args+=("$arg")
            done < <(get_resource_values "$values_yaml" "$tmpdir" "$type")
            
            kubectl "${kubectl_args[@]}"
            info "Created Secret: $name"
            ;;
        *)
            warn "Unknown resource type: $type"
            ;;
    esac
}

# Delete kubernetes resource
delete_resource() {
    local name="$1"
    local type="$2"
    
    debug "Deleting resource: $name (type: $type)"
    
    case "$type" in
        "DefaultStateValues")
            debug "DefaultStateValues detected - no resource to delete (local processing only)"
            return
            ;;
        "StateValuesConfigmap"|"Configmap")
            if kubectl get configmap "$name" >/dev/null 2>&1; then
                kubectl delete configmap "$name"
                info "Deleted ConfigMap: $name"
            else
                info "ConfigMap $name does not exist"
            fi
            ;;
        "Secrets")
            if kubectl get secret "$name" >/dev/null 2>&1; then
                kubectl delete secret "$name"
                info "Deleted Secret: $name"
            else
                info "Secret $name does not exist"
            fi
            ;;
        *)
            warn "Unknown resource type: $type"
            ;;
    esac
}

# Check resource status
check_resource_status() {
    local name="$1"
    local type="$2"
    
    case "$type" in
        "DefaultStateValues")
            echo -e "${GREEN}✓${NC} DefaultStateValues (local processing)"
            ;;
        "StateValuesConfigmap"|"Configmap")
            if kubectl get configmap "$name" >/dev/null 2>&1; then
                echo -e "${GREEN}✓${NC} ConfigMap $name exists"
            else
                echo -e "${RED}✗${NC} ConfigMap $name missing"
            fi
            ;;
        "Secrets")
            if kubectl get secret "$name" >/dev/null 2>&1; then
                echo -e "${GREEN}✓${NC} Secret $name exists"
            else
                echo -e "${RED}✗${NC} Secret $name missing"
            fi
            ;;
        *)
            echo -e "${YELLOW}?${NC} Unknown resource type: $type"
            ;;
    esac
}

# Get trait for hype name from hype-traits ConfigMap
get_hype_trait() {
    local hype_name="$1"
    
    debug "Getting trait for hype: $hype_name"
    
    # Check if hype-traits ConfigMap exists
    if ! kubectl get configmap hype-traits >/dev/null 2>&1; then
        debug "hype-traits ConfigMap does not exist"
        return 1
    fi
    
    # Get trait from ConfigMap
    local trait
    trait=$(kubectl get configmap hype-traits -o jsonpath="{.data.$hype_name}" 2>/dev/null || echo "")
    
    if [[ -n "$trait" ]]; then
        debug "Found trait for $hype_name: $trait"
        echo "$trait"
        return 0
    else
        debug "No trait found for hype: $hype_name"
        return 1
    fi
}

# Set trait for hype name in hype-traits ConfigMap
set_hype_trait() {
    local hype_name="$1"
    local trait_type="$2"
    
    debug "Setting trait for hype: $hype_name to: $trait_type"
    
    # Validate trait type format (alphanumeric + hyphens only)
    if [[ ! "$trait_type" =~ ^[a-zA-Z0-9-]+$ ]]; then
        die "Invalid trait type: $trait_type (only alphanumeric characters and hyphens allowed)"
    fi
    
    # Create or patch the hype-traits ConfigMap
    if kubectl get configmap hype-traits >/dev/null 2>&1; then
        # ConfigMap exists, patch it
        debug "Patching existing hype-traits ConfigMap"
        kubectl patch configmap hype-traits --patch "{\"data\":{\"$hype_name\":\"$trait_type\"}}"
    else
        # ConfigMap doesn't exist, create it
        debug "Creating new hype-traits ConfigMap"
        kubectl create configmap hype-traits --from-literal="$hype_name=$trait_type"
    fi
    
    info "Set trait '$trait_type' for hype: $hype_name"
}

# Remove trait for hype name from hype-traits ConfigMap
unset_hype_trait() {
    local hype_name="$1"
    
    debug "Removing trait for hype: $hype_name"
    
    # Check if hype-traits ConfigMap exists
    if ! kubectl get configmap hype-traits >/dev/null 2>&1; then
        warn "hype-traits ConfigMap does not exist"
        return 1
    fi
    
    # Check if trait exists for this hype
    if ! kubectl get configmap hype-traits -o jsonpath="{.data.$hype_name}" >/dev/null 2>&1; then
        warn "No trait set for hype: $hype_name"
        return 1
    fi
    
    # Remove the trait by patching the ConfigMap
    debug "Removing trait from hype-traits ConfigMap"
    kubectl patch configmap hype-traits --type json -p "[{\"op\": \"remove\", \"path\": \"/data/$hype_name\"}]"
    
    info "Removed trait for hype: $hype_name"
}

# Get values as kubectl arguments with resource type specific handling
get_resource_values() {
    local values_yaml="$1"
    local tmpdir="$2"
    local resource_type="$3"
    
    debug "Processing values_yaml with tmpdir: $tmpdir, resource_type: $resource_type"
    
    if [[ "$resource_type" == "StateValuesConfigmap" ]]; then
        # StateValuesConfigmap: Save entire values as single YAML file
        debug "StateValuesConfigmap detected - saving entire values as YAML"
        echo "$values_yaml" > "$tmpdir/values.yaml"
        echo "--from-file=values=$tmpdir/values.yaml"
    else
        # Regular Configmap/Secrets: Validate against complex structures
        debug "Regular $resource_type detected - validating for simple values only"
        
        # Check for complex structures (arrays/objects) and error if found
        local complex_keys
        complex_keys=$(echo "$values_yaml" \
          | yq eval -o=json - \
          | jq -r '
              to_entries[]
              | select((.value|type) == "array" or (.value|type) == "object")
              | .key
            ' \
          | tr '\n' ' ')
        
        if [[ -n "${complex_keys// }" ]]; then
            die "Error: Complex YAML structures (arrays/objects) not allowed in $resource_type. Found in keys: ${complex_keys// /,}"
        fi
        
        # Process simple values only (string/number/boolean)
        # ① Create files for multiline strings
        echo "$values_yaml" \
          | yq eval -o=json - \
          | jq -r '
              to_entries[]
              | select((.value|type) == "string" and (.value|contains("\n")))
              | "cat > \"'"$tmpdir"'/\(.key).txt\" <<'\''EOF'\''\n\(.value)\nEOF"
            ' \
          | bash
        
        # ② Generate kubectl arguments for all keys
        echo "$values_yaml" \
          | yq eval -o=json - \
          | jq -r '
              to_entries[]
              | if (.value|type) == "string" and (.value|contains("\n")) then
                  "--from-file=\(.key)='"$tmpdir"'/\(.key).txt"
                elif ((.value|type) == "string" or (.value|type) == "number" or (.value|type) == "boolean") then
                  "--from-literal=\(.key)=\(.value|tostring)"
                else
                  empty
                end
            '
    fi
}

# Initialize default resources
cmd_init() {
    local hype_name="$1"
    
    info "Initializing resources for: $hype_name"
    
    parse_hypefile "$hype_name"
    
    if [[ ! -f "$HYPE_SECTION_FILE" ]]; then
        info "No hypefile section found"
        return
    fi
    
    # Get resource count first
    local resource_count
    resource_count=$(yq eval '.defaultResources | length' "$HYPE_SECTION_FILE" 2>/dev/null || echo "0")
    
    if [[ "$resource_count" -eq 0 ]]; then
        info "No default resources found"
        return
    fi
    
    # Process each default resource by index
    for (( i=0; i<resource_count; i++ )); do
        local name type values_yaml
        
        name=$(yq eval ".defaultResources[$i].name" "$HYPE_SECTION_FILE" | sed "s/{{ \.Hype\.Name }}/$hype_name/g" | sed "s|{{ \.Hype\.CurrentDirectory }}|$(pwd)|g")
        type=$(yq eval ".defaultResources[$i].type" "$HYPE_SECTION_FILE")
        values_yaml=$(yq eval ".defaultResources[$i].values" "$HYPE_SECTION_FILE")
        
        debug "Processing resource $i: name=$name, type=$type"
        
        if [[ "$name" != "null" && "$type" != "null" && "$values_yaml" != "null" ]]; then
            create_resource "$name" "$type" "$values_yaml"
        fi
    done
    
    info "Initialization completed for: $hype_name"
}

# Deinitialize default resources
cmd_deinit() {
    local hype_name="$1"
    
    info "Deinitializing resources for: $hype_name"
    
    parse_hypefile "$hype_name"
    
    if [[ ! -f "$HYPE_SECTION_FILE" ]]; then
        info "No hypefile section found"
        return
    fi
    
    # Get resource count first
    local resource_count
    resource_count=$(yq eval '.defaultResources | length' "$HYPE_SECTION_FILE" 2>/dev/null || echo "0")
    
    if [[ "$resource_count" -eq 0 ]]; then
        info "No default resources found"
        return
    fi
    
    # Process each default resource by index
    for (( i=0; i<resource_count; i++ )); do
        local name type
        
        name=$(yq eval ".defaultResources[$i].name" "$HYPE_SECTION_FILE" | sed "s/{{ \.Hype\.Name }}/$hype_name/g" | sed "s|{{ \.Hype\.CurrentDirectory }}|$(pwd)|g")
        type=$(yq eval ".defaultResources[$i].type" "$HYPE_SECTION_FILE")
        
        debug "Processing resource $i for deletion: name=$name, type=$type"
        
        if [[ "$name" != "null" && "$type" != "null" ]]; then
            delete_resource "$name" "$type"
        fi
    done
    
    
    info "Deinitialization completed for: $hype_name"
}

# Show resources status
cmd_check_resources() {
    local hype_name="$1"
    
    info "Resource status for: $hype_name"
    echo
    
    parse_hypefile "$hype_name"
    
    if [[ ! -f "$HYPE_SECTION_FILE" ]]; then
        info "No hypefile section found"
        return
    fi
    
    # Get resource count first
    local resource_count
    resource_count=$(yq eval '.defaultResources | length' "$HYPE_SECTION_FILE" 2>/dev/null || echo "0")
    
    if [[ "$resource_count" -eq 0 ]]; then
        info "No default resources found"
        return
    fi
    
    # Check status of each default resource
    for (( i=0; i<resource_count; i++ )); do
        local name type
        
        name=$(yq eval ".defaultResources[$i].name" "$HYPE_SECTION_FILE" | sed "s/{{ \.Hype\.Name }}/$hype_name/g" | sed "s|{{ \.Hype\.CurrentDirectory }}|$(pwd)|g")
        type=$(yq eval ".defaultResources[$i].type" "$HYPE_SECTION_FILE")
        
        if [[ "$type" != "null" ]]; then
            if [[ "$type" == "DefaultStateValues" ]]; then
                # DefaultStateValues doesn't have a name, use type for status
                check_resource_status "" "$type"
            elif [[ "$name" != "null" ]]; then
                check_resource_status "$name" "$type"
            fi
        fi
    done
}

# Show rendered hype section template (original functionality)
cmd_template_hype_section() {
    local hype_name="$1"
    
    info "Rendered hype section for: $hype_name"
    echo
    
    parse_hypefile "$hype_name"
    
    # Output the rendered hype section
    if [[ -f "$HYPE_SECTION_FILE" ]]; then
        cat "$HYPE_SECTION_FILE"
    else
        warn "No hype section found in hypefile"
    fi
}

# Template command router
cmd_template() {
    local hype_name="$1"
    local subcommand="${2:-}"
    
    case "$subcommand" in
        "state-values")
            local configmap_name="${3:-}"
            cmd_template_state_value "$hype_name" "$configmap_name"
            ;;
        "")
            cmd_template_hype_section "$hype_name"
            ;;
        *)
            error "Unknown template subcommand: $subcommand"
            error "Valid options: state-values"
            exit 1
            ;;
    esac
}

# Show state-values file content for StateValuesConfigmap
cmd_template_state_value() {
    local hype_name="$1"
    local configmap_name="$2"
    
    if [[ -z "$configmap_name" ]]; then
        error "ConfigMap name is required"
        error "Usage: hype <hype-name> template state-values <configmap-name>"
        exit 1
    fi
    
    info "State-value file content for ConfigMap: $configmap_name"
    echo
    
    # Validate the configmap
    if ! validate_state_values_configmap "$hype_name" "$configmap_name"; then
        exit 1
    fi
    
    # Extract YAML content from ConfigMap data.values key
    local state_values
    if ! state_values=$(kubectl get configmap "$configmap_name" -o jsonpath='{.data.values}' 2>/dev/null); then
        error "Failed to extract state values from ConfigMap: $configmap_name"
        exit 1
    fi
    
    # Verify the state values are not empty
    if [[ -z "$state_values" ]]; then
        error "ConfigMap $configmap_name contains no values data"
        exit 1
    fi
    
    debug "Successfully extracted state values from ConfigMap: $configmap_name"
    
    # Output the state values content
    echo "$state_values"
}

# Parse command router
cmd_parse() {
    local hype_name="$1"
    local subcommand="${2:-}"
    
    case "$subcommand" in
        "section")
            local section_type="${3:-}"
            cmd_parse_section "$hype_name" "$section_type"
            ;;
        "")
            error "Missing parse subcommand"
            error "Usage: hype <hype-name> parse section [hype|helmfile]"
            exit 1
            ;;
        *)
            error "Unknown parse subcommand: $subcommand"
            error "Valid options: section"
            exit 1
            ;;
    esac
}

# Show raw sections without rendering info headers
cmd_parse_section() {
    local hype_name="$1"
    local section_type="$2"
    
    if [[ -z "$section_type" ]]; then
        error "Section type is required"
        error "Usage: hype <hype-name> parse section [hype|helmfile]"
        exit 1
    fi
    
    parse_hypefile "$hype_name"
    
    case "$section_type" in
        "hype")
            if [[ -f "$HYPE_SECTION_FILE" ]]; then
                cat "$HYPE_SECTION_FILE"
            fi
            ;;
        "helmfile")
            if [[ -f "$HELMFILE_SECTION_FILE" ]]; then
                cat "$HELMFILE_SECTION_FILE"
            fi
            ;;
        "taskfile")
            if [[ -f "$TASKFILE_SECTION_FILE" ]]; then
                cat "$TASKFILE_SECTION_FILE"
            fi
            ;;
        *)
            error "Unknown section type: $section_type"
            error "Valid options: hype, helmfile, taskfile"
            exit 1
            ;;
    esac
}

# Handle trait commands
cmd_trait() {
    local hype_name="$1"
    local subcommand="${2:-}"
    local trait_type="${3:-}"
    
    case "$subcommand" in
        "")
            # Show current trait
            local current_trait
            if current_trait=$(get_hype_trait "$hype_name" 2>/dev/null); then
                echo "$current_trait"
            else
                echo "No trait set"
            fi
            ;;
        "set")
            if [[ -z "$trait_type" ]]; then
                error "Trait type is required"
                error "Usage: hype <hype-name> trait set <trait-type>"
                exit 1
            fi
            set_hype_trait "$hype_name" "$trait_type"
            ;;
        "unset")
            if ! unset_hype_trait "$hype_name"; then
                exit 1
            fi
            ;;
        *)
            error "Unknown trait subcommand: $subcommand"
            error "Valid options: set, unset"
            exit 1
            ;;
    esac
}

# Self-upgrade command
cmd_upgrade() {
    info "Checking for HYPE CLI updates..."
    
    # Check if curl or wget is available
    local download_tool=""
    if command -v curl >/dev/null 2>&1; then
        download_tool="curl"
    elif command -v wget >/dev/null 2>&1; then
        download_tool="wget"
    else
        die "Neither curl nor wget found. Please install one of them to use upgrade functionality."
    fi
    
    # Get latest release information from GitHub API
    local repo_owner="${HYPE_REPO_OWNER:-foontype}"
    local repo_name="${HYPE_REPO_NAME:-hype}"
    local api_url="https://api.github.com/repos/${repo_owner}/${repo_name}/releases/latest"
    local release_info
    
    if [[ "$download_tool" == "curl" ]]; then
        if ! release_info=$(curl -s "$api_url"); then
            die "Failed to fetch release information from GitHub API"
        fi
    else
        if ! release_info=$(wget -qO- "$api_url"); then
            die "Failed to fetch release information from GitHub API"
        fi
    fi
    
    # Extract latest version and download URL
    local latest_version download_url
    if ! command -v jq >/dev/null 2>&1; then
        # Fallback parsing without jq (basic regex)
        latest_version=$(echo "$release_info" | grep '"tag_name"' | head -1 | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/')
        download_url=$(echo "$release_info" | grep '"browser_download_url".*hype"' | head -1 | sed 's/.*"browser_download_url": *"\([^"]*\)".*/\1/')
    else
        latest_version=$(echo "$release_info" | jq -r '.tag_name')
        download_url=$(echo "$release_info" | jq -r '.assets[] | select(.name == "hype") | .browser_download_url')
    fi
    
    if [[ -z "$latest_version" || -z "$download_url" ]]; then
        die "Failed to extract version or download URL from GitHub API response"
    fi
    
    # Remove 'v' prefix from version for comparison
    latest_version_clean="${latest_version#v}"
    
    debug "Current version: $HYPE_VERSION"
    debug "Latest version: $latest_version_clean"
    debug "Download URL: $download_url"
    
    # Compare versions
    if [[ "$HYPE_VERSION" == "$latest_version_clean" ]]; then
        info "HYPE CLI is already up to date (version $HYPE_VERSION)"
        return 0
    fi
    
    info "New version available: $latest_version_clean (current: $HYPE_VERSION)"
    info "Downloading update from: $download_url"
    
    # Determine the path of the current script
    local script_path
    script_path=$(readlink -f "${BASH_SOURCE[0]}")
    local backup_path="${script_path}.backup"
    
    debug "Script path: $script_path"
    debug "Backup path: $backup_path"
    
    # Create backup of current version
    if ! cp "$script_path" "$backup_path"; then
        die "Failed to create backup of current version"
    fi
    
    info "Created backup: $backup_path"
    
    # Download new version to temporary file
    local temp_file
    temp_file=$(mktemp)
    
    if [[ "$download_tool" == "curl" ]]; then
        if ! curl -L -o "$temp_file" "$download_url"; then
            rm -f "$temp_file"
            die "Failed to download new version"
        fi
    else
        if ! wget -O "$temp_file" "$download_url"; then
            rm -f "$temp_file"
            die "Failed to download new version"
        fi
    fi
    
    # Verify download (basic check - file should not be empty and should be executable script)
    if [[ ! -s "$temp_file" ]]; then
        rm -f "$temp_file"
        die "Downloaded file is empty"
    fi
    
    # Check if it's a bash script
    if ! head -1 "$temp_file" | grep -q "#!/bin/bash"; then
        rm -f "$temp_file"
        die "Downloaded file does not appear to be a valid bash script"
    fi
    
    # Replace current script with new version
    if ! cp "$temp_file" "$script_path"; then
        # Restore from backup if replacement fails
        cp "$backup_path" "$script_path"
        rm -f "$temp_file"
        die "Failed to replace script. Restored from backup."
    fi
    
    # Set executable permissions
    if ! chmod +x "$script_path"; then
        # Restore from backup if chmod fails
        cp "$backup_path" "$script_path"
        rm -f "$temp_file"
        die "Failed to set executable permissions. Restored from backup."
    fi
    
    # Clean up
    rm -f "$temp_file"
    
    info "Successfully updated HYPE CLI to version $latest_version_clean"
    info "Backup of previous version saved as: $backup_path"
    info "Run 'hype --version' to verify the update"
}

# Run task command
cmd_task() {
    local hype_name="$1"
    local task_name="$2"
    shift 2
    local task_args=("$@")
    
    if [[ -z "$task_name" ]]; then
        error "Task name is required"
        error "Usage: hype <hype-name> task <task-name> [args...]"
        exit 1
    fi
    
    info "Running task '$task_name' for: $hype_name"
    debug "Task args: ${task_args[*]}"
    
    parse_hypefile "$hype_name"
    
    # Check if taskfile section exists
    if [[ ! -f "$TASKFILE_SECTION_FILE" || ! -s "$TASKFILE_SECTION_FILE" ]]; then
        error "No taskfile section found in hypefile"
        error "Add a taskfile section after the second '---' separator"
        exit 1
    fi
    
    # Validate task exists in taskfile using task command itself
    if ! task --taskfile "$TASKFILE_SECTION_FILE" --list-all 2>/dev/null | grep -E "^\* $task_name:" >/dev/null 2>&1; then
        # Fallback: show all available tasks
        local all_tasks
        all_tasks=$(task --taskfile "$TASKFILE_SECTION_FILE" --list-all 2>/dev/null | grep -E "^\*" | sed 's/^\* //' | cut -d: -f1 | tr '\n' ' ' | sed 's/ $//')
        
        error "Task '$task_name' not found in taskfile section"
        if [[ -n "$all_tasks" ]]; then
            error "Available tasks: ${all_tasks// /, }"
        fi
        exit 1
    fi
    
    # Check if task command is available
    if ! command -v task >/dev/null 2>&1; then
        die "Task runner 'task' not found. Please install go-task: https://taskfile.dev/installation/"
    fi
    
    # Set up environment variables for the task
    export HYPE_NAME="$hype_name"
    local current_dir
    current_dir="$(pwd)"
    export HYPE_CURRENT_DIRECTORY="$current_dir"
    
    # Set trait if available
    local trait_value
    if trait_value=$(get_hype_trait "$hype_name" 2>/dev/null); then
        export HYPE_TRAIT="$trait_value"
        debug "Set HYPE_TRAIT environment variable: $trait_value"
    else
        unset HYPE_TRAIT
        debug "No trait set, HYPE_TRAIT environment variable unset"
    fi
    
    debug "Set environment variables - HYPE_NAME: $hype_name, HYPE_CURRENT_DIRECTORY: $(pwd)"
    
    # Run task with the temporary taskfile in the hype project directory
    local cmd=("task" "--taskfile" "$TASKFILE_SECTION_FILE" "$task_name")
    
    # Add user-provided arguments
    if [[ ${#task_args[@]} -gt 0 ]]; then
        cmd+=("--" "${task_args[@]}")
    fi
    
    debug "Executing: ${cmd[*]} (in directory: $(dirname "$HYPEFILE_PATH"))"
    
    # Change to hype project directory and execute task
    (cd "$(dirname "$HYPEFILE_PATH")" && "${cmd[@]}")
}

# Run helmfile command
cmd_helmfile() {
    local hype_name="$1"
    shift
    local helmfile_args=("$@")
    
    info "Running helmfile for: $hype_name"
    debug "Helmfile args: ${helmfile_args[*]}"
    
    parse_hypefile "$hype_name"
    
    # Build helmfile command
    local cmd=("helmfile" "-f" "$HELMFILE_SECTION_FILE" "-e" "$hype_name")
    
    # Add current directory and trait as state values
    local current_dir_state_file
    current_dir_state_file=$(mktemp --suffix=.yaml)
    
    # Get trait value if available
    local trait_value
    if trait_value=$(get_hype_trait "$hype_name" 2>/dev/null); then
        debug "Adding trait to state values: $trait_value"
        cat > "$current_dir_state_file" << EOF
Hype:
  CurrentDirectory: "$(pwd)"
  Name: "$hype_name"
  Trait: "$trait_value"
EOF
    else
        debug "No trait found, using default state values"
        cat > "$current_dir_state_file" << EOF
Hype:
  CurrentDirectory: "$(pwd)"
  Name: "$hype_name"
EOF
    fi
    
    cmd+=("--state-values-file" "$current_dir_state_file")
    
    debug "Added Hype state values - CurrentDirectory: $(pwd), Name: $hype_name"
    
    # Clean up current directory state file when done
    # shellcheck disable=SC2064
    trap "rm -f '$current_dir_state_file'" EXIT
    
    # Add state-values-file for DefaultStateValues and StateValuesConfigmap resources
    if [[ -f "$HYPE_SECTION_FILE" ]]; then
        local resource_count
        resource_count=$(yq eval '.defaultResources | length' "$HYPE_SECTION_FILE" 2>/dev/null || echo "0")
        
        # First pass: Process DefaultStateValues (highest priority)
        for (( i=0; i<resource_count; i++ )); do
            local type
            type=$(yq eval ".defaultResources[$i].type" "$HYPE_SECTION_FILE")
            
            if [[ "$type" == "DefaultStateValues" ]]; then
                # Create temporary state values file for DefaultStateValues
                local default_state_file
                default_state_file=$(mktemp --suffix=.yaml)
                
                # Extract values directly from the YAML resource
                if ! yq eval ".defaultResources[$i].values" "$HYPE_SECTION_FILE" > "$default_state_file" 2>/dev/null; then
                    error "Failed to extract values from DefaultStateValues resource"
                    continue
                fi
                
                # Verify the state file is not empty
                if [[ ! -s "$default_state_file" ]]; then
                    error "DefaultStateValues resource contains no values data"
                    continue
                fi
                
                cmd+=("--state-values-file" "$default_state_file")
                
                debug "Added DefaultStateValues state-values-file: $default_state_file"
                
                # Debug: Show contents of DefaultStateValues file
                if [[ "$DEBUG" == "true" ]]; then
                    debug "=== DEFAULT STATE VALUES FILE CONTENT ==="
                    cat "$default_state_file" >&2
                    debug "=== END DEFAULT STATE VALUES FILE ==="
                fi
                
                # Clean up default state file when done
                # shellcheck disable=SC2064
                trap "rm -f '$default_state_file'" EXIT
            fi
        done
        
        # Second pass: Process StateValuesConfigmap resources in reverse order
        # (later resources in hypefile get higher priority in state-values-file)
        for (( i=resource_count-1; i>=0; i-- )); do
            local name type
            
            name=$(yq eval ".defaultResources[$i].name" "$HYPE_SECTION_FILE" | sed "s/{{ \.Hype\.Name }}/$hype_name/g" | sed "s|{{ \.Hype\.CurrentDirectory }}|$(pwd)|g")
            type=$(yq eval ".defaultResources[$i].type" "$HYPE_SECTION_FILE")
            
            if [[ "$type" == "StateValuesConfigmap" && "$name" != "null" ]]; then
                # Create temporary state values file
                local state_file
                state_file=$(mktemp --suffix=.yaml)
                
                # Extract YAML content directly from ConfigMap data.values key
                if ! kubectl get configmap "$name" -o jsonpath='{.data.values}' > "$state_file" 2>/dev/null; then
                    error "Failed to extract state values from StateValuesConfigmap: $name"
                    continue
                fi
                
                # Verify the state file is not empty
                if [[ ! -s "$state_file" ]]; then
                    error "StateValuesConfigmap $name contains no values data"
                    continue
                fi
                cmd+=("--state-values-file" "$state_file")
                
                debug "Added state-values-file: $state_file for ConfigMap: $name"
                
                # Debug: Show contents of state values file
                if [[ "$DEBUG" == "true" ]]; then
                    debug "=== STATE VALUES FILE CONTENT ($name) ==="
                    cat "$state_file" >&2
                    debug "=== END STATE VALUES FILE ==="
                fi
                
                # Clean up state file when done
                # shellcheck disable=SC2064
                trap "rm -f '$state_file'" EXIT
            fi
        done
    fi
    
    # Add user-provided arguments
    cmd+=("${helmfile_args[@]}")
    
    debug "Executing: ${cmd[*]}"
    "${cmd[@]}"
}

# Main function
main() {
    if [[ $# -eq 0 ]]; then
        show_help
        exit 1
    fi
    
    case "${1:-}" in
        "--help"|"-h")
            show_help
            ;;
        "--version"|"-v")
            show_version
            ;;
        "upgrade")
            cmd_upgrade
            ;;
        *)
            if [[ $# -lt 2 ]]; then
                error "Missing required arguments"
                show_help
                exit 1
            fi
            
            local hype_name="$1"
            local command="$2"
            shift 2
            
            # Validate hype name
            if [[ ! "$hype_name" =~ ^[a-zA-Z0-9-]+$ ]]; then
                die "Invalid hype name: $hype_name (only alphanumeric characters and hyphens allowed)"
            fi
            
            check_dependencies
            
            case "$command" in
                "init")
                    cmd_init "$hype_name"
                    ;;
                "deinit")
                    cmd_deinit "$hype_name"
                    ;;
                "check")
                    cmd_check_resources "$hype_name"
                    ;;
                "template")
                    cmd_template "$hype_name" "$@"
                    ;;
                "parse")
                    cmd_parse "$hype_name" "$@"
                    ;;
                "trait")
                    cmd_trait "$hype_name" "$@"
                    ;;
                "task")
                    cmd_task "$hype_name" "$@"
                    ;;
                "helmfile")
                    cmd_helmfile "$hype_name" "$@"
                    ;;
                *)
                    error "Unknown command: $command"
                    show_help
                    exit 1
                    ;;
            esac
            ;;
    esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi