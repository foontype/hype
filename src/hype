#!/bin/bash

set -euo pipefail

HYPE_VERSION="0.3.4"
HYPEFILE="${HYPEFILE:-hypefile.yaml}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Debug and trace modes
DEBUG="${DEBUG:-false}"
TRACE="${TRACE:-false}"

# Enable trace mode if requested
if [[ "$TRACE" == "true" ]]; then
    set -x
fi

debug() {
    if [[ "$DEBUG" == "true" ]]; then
        echo -e "${BLUE}[DEBUG]${NC} $*" >&2
    fi
}

info() {
    echo -e "${GREEN}[INFO]${NC} $*"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $*"
}

error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

die() {
    error "$@"
    exit 1
}

# Check if required tools are available
check_dependencies() {
    local missing=()
    
    if ! command -v kubectl >/dev/null 2>&1; then
        missing+=("kubectl")
    fi
    
    if ! command -v helmfile >/dev/null 2>&1; then
        missing+=("helmfile")
    fi
    
    # Check for correct yq version (mikefarah/yq)
    if ! command -v yq >/dev/null 2>&1; then
        missing+=("yq")
    elif ! yq --version 2>&1 | grep -q "mikefarah"; then
        error "Wrong yq version detected. Please install mikefarah/yq"
        missing+=("yq (mikefarah version)")
    fi
    
    # Check for helm diff plugin
    if ! helm plugin list | grep -q "diff"; then
        missing+=("helm-diff plugin")
    fi
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        die "Missing required dependencies: ${missing[*]}"
    fi
}

# Show help
show_help() {
    cat <<EOF
HYPE CLI - Helmfile Wrapper Tool for Kubernetes AI Deployments

Usage:
  hype <hype-name> init                         Create default resources
  hype <hype-name> deinit                       Delete default resources  
  hype <hype-name> check                        List default resources status
  hype <hype-name> template                     Show rendered hype section YAML
  hype <hype-name> section [hype|helmfile]      Show raw section without headers
  hype <hype-name> helmfile <helmfile-options>  Run helmfile command
  hype <hype-name> test template state-value <name>  Generate state-value test template
  hype --version                                Show version
  hype --help                                   Show this help

Options:
  --version                Show version information
  --help                   Show help information

Environment Variables:
  HYPEFILE                 Path to hypefile.yaml (default: hypefile.yaml)
  DEBUG                    Enable debug output (default: false)
  TRACE                    Enable bash trace mode with set -x (default: false)

Examples:
  hype my-nginx init                           Create resources for my-nginx
  hype my-nginx template                       Show rendered YAML for my-nginx
  hype my-nginx section hype                   Show raw hype section
  hype my-nginx section helmfile               Show raw helmfile section
  hype my-nginx section                        Show raw hype section (default)
  hype my-nginx helmfile apply                 Apply helmfile for my-nginx
  hype my-nginx check                          Check resource status
  hype my-nginx deinit                         Remove all resources
  hype my-nginx test template state-value app  Generate state-value template for 'app'

EOF
}

# Show version
show_version() {
    echo "HYPE CLI version $HYPE_VERSION"
}

# Parse hypefile.yaml and split into hype and helmfile sections
parse_hypefile() {
    local hype_name="$1"
    
    if [[ ! -f "$HYPEFILE" ]]; then
        die "Hypefile not found: $HYPEFILE"
    fi
    
    debug "Parsing hypefile: $HYPEFILE"
    
    # Create temporary files
    HYPE_SECTION_FILE=$(mktemp)
    HELMFILE_SECTION_FILE=$(mktemp --suffix=.yaml.gotmpl)
    
    # Split file on "---" separator
    awk -v hype_file="$HYPE_SECTION_FILE" -v helmfile_file="$HELMFILE_SECTION_FILE" '
    BEGIN { section = "hype" }
    /^---$/ { section = "helmfile"; next }
    section == "hype" { print > hype_file }
    section == "helmfile" { print > helmfile_file }
    ' "$HYPEFILE"
    
    # Replace {{ .Hype.Name }} with actual hype name
    sed -i "s/{{ \.Hype\.Name }}/$hype_name/g" "$HYPE_SECTION_FILE"
    sed -i "s/{{ \.Hype\.Name }}/$hype_name/g" "$HELMFILE_SECTION_FILE"
    
    debug "Created temporary files: $HYPE_SECTION_FILE, $HELMFILE_SECTION_FILE"
    
    # Debug: Show contents of temporary files
    if [[ "$DEBUG" == "true" ]]; then
        debug "=== HYPE SECTION CONTENT ==="
        cat "$HYPE_SECTION_FILE" >&2
        debug "=== END HYPE SECTION ==="
        
        debug "=== HELMFILE SECTION CONTENT ==="
        cat "$HELMFILE_SECTION_FILE" >&2
        debug "=== END HELMFILE SECTION ==="
    fi
}

# Cleanup temporary files
cleanup() {
    if [[ -n "${HYPE_SECTION_FILE:-}" && -f "$HYPE_SECTION_FILE" ]]; then
        rm -f "$HYPE_SECTION_FILE"
    fi
    if [[ -n "${HELMFILE_SECTION_FILE:-}" && -f "$HELMFILE_SECTION_FILE" ]]; then
        rm -f "$HELMFILE_SECTION_FILE"
    fi
}

trap cleanup EXIT

# Get default resources from hype section
get_default_resources() {
    if [[ ! -f "$HYPE_SECTION_FILE" ]]; then
        return
    fi
    
    yq eval '.defaultResources[]' "$HYPE_SECTION_FILE" 2>/dev/null || true
}

# Create kubernetes resource
create_resource() {
    local name="$1"
    local type="$2"
    local values_yaml="$3"
    local tmpdir
    
    debug "Creating resource: $name (type: $type)"
    
    # Create temporary directory for complex values
    tmpdir=$(mktemp -d)
    # shellcheck disable=SC2064
    trap "rm -rf '$tmpdir'" EXIT
    
    case "$type" in
        "StateValueConfigmap"|"Configmap")
            if kubectl get configmap "$name" >/dev/null 2>&1; then
                info "ConfigMap $name already exists"
                return
            fi
            
            # Create configmap from values using new logic
            local kubectl_args=("create" "configmap" "$name")
            while IFS= read -r arg; do
                [[ -n "$arg" ]] && kubectl_args+=("$arg")
            done < <(get_resource_values "$values_yaml" "$tmpdir" "$type")
            
            kubectl "${kubectl_args[@]}"
            info "Created ConfigMap: $name"
            ;;
        "Secrets")
            if kubectl get secret "$name" >/dev/null 2>&1; then
                info "Secret $name already exists"
                return
            fi
            
            # Create secret from values using new logic
            local kubectl_args=("create" "secret" "generic" "$name")
            while IFS= read -r arg; do
                [[ -n "$arg" ]] && kubectl_args+=("$arg")
            done < <(get_resource_values "$values_yaml" "$tmpdir" "$type")
            
            kubectl "${kubectl_args[@]}"
            info "Created Secret: $name"
            ;;
        *)
            warn "Unknown resource type: $type"
            ;;
    esac
}

# Delete kubernetes resource
delete_resource() {
    local name="$1"
    local type="$2"
    
    debug "Deleting resource: $name (type: $type)"
    
    case "$type" in
        "StateValueConfigmap"|"Configmap")
            if kubectl get configmap "$name" >/dev/null 2>&1; then
                kubectl delete configmap "$name"
                info "Deleted ConfigMap: $name"
            else
                info "ConfigMap $name does not exist"
            fi
            ;;
        "Secrets")
            if kubectl get secret "$name" >/dev/null 2>&1; then
                kubectl delete secret "$name"
                info "Deleted Secret: $name"
            else
                info "Secret $name does not exist"
            fi
            ;;
        *)
            warn "Unknown resource type: $type"
            ;;
    esac
}

# Check resource status
check_resource_status() {
    local name="$1"
    local type="$2"
    
    case "$type" in
        "StateValueConfigmap"|"Configmap")
            if kubectl get configmap "$name" >/dev/null 2>&1; then
                echo -e "${GREEN}✓${NC} ConfigMap $name exists"
            else
                echo -e "${RED}✗${NC} ConfigMap $name missing"
            fi
            ;;
        "Secrets")
            if kubectl get secret "$name" >/dev/null 2>&1; then
                echo -e "${GREEN}✓${NC} Secret $name exists"
            else
                echo -e "${RED}✗${NC} Secret $name missing"
            fi
            ;;
        *)
            echo -e "${YELLOW}?${NC} Unknown resource type: $type"
            ;;
    esac
}

# Get values as kubectl arguments with resource type specific handling
get_resource_values() {
    local values_yaml="$1"
    local tmpdir="$2"
    local resource_type="$3"
    
    debug "Processing values_yaml with tmpdir: $tmpdir, resource_type: $resource_type"
    
    if [[ "$resource_type" == "StateValueConfigmap" ]]; then
        # StateValueConfigmap: Save entire values as single YAML file
        debug "StateValueConfigmap detected - saving entire values as YAML"
        echo "$values_yaml" > "$tmpdir/values.yaml"
        echo "--from-file=values=$tmpdir/values.yaml"
    else
        # Regular Configmap/Secrets: Validate against complex structures
        debug "Regular $resource_type detected - validating for simple values only"
        
        # Check for complex structures (arrays/objects) and error if found
        local complex_keys
        complex_keys=$(echo "$values_yaml" \
          | yq eval -o=json - \
          | jq -r '
              to_entries[]
              | select((.value|type) == "array" or (.value|type) == "object")
              | .key
            ' \
          | tr '\n' ' ')
        
        if [[ -n "${complex_keys// }" ]]; then
            die "Error: Complex YAML structures (arrays/objects) not allowed in $resource_type. Found in keys: ${complex_keys// /,}"
        fi
        
        # Process simple values only (string/number/boolean)
        # ① Create files for multiline strings
        echo "$values_yaml" \
          | yq eval -o=json - \
          | jq -r '
              to_entries[]
              | select((.value|type) == "string" and (.value|contains("\n")))
              | "cat > \"'"$tmpdir"'/\(.key).txt\" <<'\''EOF'\''\n\(.value)\nEOF"
            ' \
          | bash
        
        # ② Generate kubectl arguments for all keys
        echo "$values_yaml" \
          | yq eval -o=json - \
          | jq -r '
              to_entries[]
              | if (.value|type) == "string" and (.value|contains("\n")) then
                  "--from-file=\(.key)='"$tmpdir"'/\(.key).txt"
                elif ((.value|type) == "string" or (.value|type) == "number" or (.value|type) == "boolean") then
                  "--from-literal=\(.key)=\(.value|tostring)"
                else
                  empty
                end
            '
    fi
}

# Initialize default resources
cmd_init() {
    local hype_name="$1"
    
    info "Initializing resources for: $hype_name"
    
    parse_hypefile "$hype_name"
    
    if [[ ! -f "$HYPE_SECTION_FILE" ]]; then
        info "No hypefile section found"
        return
    fi
    
    # Get resource count first
    local resource_count
    resource_count=$(yq eval '.defaultResources | length' "$HYPE_SECTION_FILE" 2>/dev/null || echo "0")
    
    if [[ "$resource_count" -eq 0 ]]; then
        info "No default resources found"
        return
    fi
    
    # Process each default resource by index
    for (( i=0; i<resource_count; i++ )); do
        local name type values_yaml
        
        name=$(yq eval ".defaultResources[$i].name" "$HYPE_SECTION_FILE" | sed "s/{{ \.Hype\.Name }}/$hype_name/g")
        type=$(yq eval ".defaultResources[$i].type" "$HYPE_SECTION_FILE")
        values_yaml=$(yq eval ".defaultResources[$i].values" "$HYPE_SECTION_FILE")
        
        debug "Processing resource $i: name=$name, type=$type"
        
        if [[ "$name" != "null" && "$type" != "null" && "$values_yaml" != "null" ]]; then
            create_resource "$name" "$type" "$values_yaml"
        fi
    done
    
    info "Initialization completed for: $hype_name"
}

# Deinitialize default resources
cmd_deinit() {
    local hype_name="$1"
    
    info "Deinitializing resources for: $hype_name"
    
    parse_hypefile "$hype_name"
    
    if [[ ! -f "$HYPE_SECTION_FILE" ]]; then
        info "No hypefile section found"
        return
    fi
    
    # Get resource count first
    local resource_count
    resource_count=$(yq eval '.defaultResources | length' "$HYPE_SECTION_FILE" 2>/dev/null || echo "0")
    
    if [[ "$resource_count" -eq 0 ]]; then
        info "No default resources found"
        return
    fi
    
    # Process each default resource by index
    for (( i=0; i<resource_count; i++ )); do
        local name type
        
        name=$(yq eval ".defaultResources[$i].name" "$HYPE_SECTION_FILE" | sed "s/{{ \.Hype\.Name }}/$hype_name/g")
        type=$(yq eval ".defaultResources[$i].type" "$HYPE_SECTION_FILE")
        
        debug "Processing resource $i for deletion: name=$name, type=$type"
        
        if [[ "$name" != "null" && "$type" != "null" ]]; then
            delete_resource "$name" "$type"
        fi
    done
    
    info "Deinitialization completed for: $hype_name"
}

# Show resources status
cmd_check_resources() {
    local hype_name="$1"
    
    info "Resource status for: $hype_name"
    echo
    
    parse_hypefile "$hype_name"
    
    if [[ ! -f "$HYPE_SECTION_FILE" ]]; then
        info "No hypefile section found"
        return
    fi
    
    # Get resource count first
    local resource_count
    resource_count=$(yq eval '.defaultResources | length' "$HYPE_SECTION_FILE" 2>/dev/null || echo "0")
    
    if [[ "$resource_count" -eq 0 ]]; then
        info "No default resources found"
        return
    fi
    
    # Check status of each default resource
    for (( i=0; i<resource_count; i++ )); do
        local name type
        
        name=$(yq eval ".defaultResources[$i].name" "$HYPE_SECTION_FILE" | sed "s/{{ \.Hype\.Name }}/$hype_name/g")
        type=$(yq eval ".defaultResources[$i].type" "$HYPE_SECTION_FILE")
        
        if [[ "$name" != "null" && "$type" != "null" ]]; then
            check_resource_status "$name" "$type"
        fi
    done
}

# Show rendered hype section template
cmd_template() {
    local hype_name="$1"
    
    info "Rendered hype section for: $hype_name"
    echo
    
    parse_hypefile "$hype_name"
    
    # Output the rendered hype section
    if [[ -f "$HYPE_SECTION_FILE" ]]; then
        cat "$HYPE_SECTION_FILE"
    else
        warn "No hype section found in hypefile"
    fi
}

# Show raw sections without rendering info headers
cmd_section() {
    local hype_name="$1"
    local section_type="${2:-hype}"
    
    parse_hypefile "$hype_name"
    
    case "$section_type" in
        "hype")
            if [[ -f "$HYPE_SECTION_FILE" ]]; then
                cat "$HYPE_SECTION_FILE"
            fi
            ;;
        "helmfile")
            if [[ -f "$HELMFILE_SECTION_FILE" ]]; then
                cat "$HELMFILE_SECTION_FILE"
            fi
            ;;
        *)
            error "Unknown section type: $section_type"
            error "Valid options: hype, helmfile"
            exit 1
            ;;
    esac
}

# Generate and show state-value test template
cmd_test_template_state_value() {
    local name="$1"
    
    if [[ -z "$name" ]]; then
        die "State-value name is required"
    fi
    
    info "Generated state-value template for: $name"
    echo
    
    cat << EOF
# State-value test template for: $name
# Copy and modify this template for your use case

stateValues:
  $name:
    # Basic configuration
    enabled: true
    replicas: 3
    version: "1.0.0"
    
    # Environment settings
    environment: "development"
    debug: false
    
    # Resource limits
    resources:
      requests:
        cpu: "100m"
        memory: "128Mi"
      limits:
        cpu: "500m"
        memory: "512Mi"
    
    # Application configuration
    config:
      database:
        host: "localhost"
        port: 5432
        name: "${name}_db"
      
      api:
        endpoint: "https://api.${name}.example.com"
        timeout: 30
        retries: 3
      
      features:
        - "feature1"
        - "feature2"
        - "feature3"
    
    # Secret references (use actual secrets in production)
    secrets:
      apiKey: "your-api-key-here"
      dbPassword: "your-db-password-here"
      
    # Custom labels and annotations
    metadata:
      labels:
        app: "$name"
        version: "1.0.0"
        environment: "development"
      annotations:
        description: "State-value template for $name"
        generated-by: "hype test template state-value"

EOF
}

# Run helmfile command
cmd_helmfile() {
    local hype_name="$1"
    shift
    local helmfile_args=("$@")
    
    info "Running helmfile for: $hype_name"
    debug "Helmfile args: ${helmfile_args[*]}"
    
    parse_hypefile "$hype_name"
    
    # Build helmfile command
    local cmd=("helmfile" "-f" "$HELMFILE_SECTION_FILE" "-e" "$hype_name")
    
    # Add current directory as state value
    local current_dir_state_file
    current_dir_state_file=$(mktemp --suffix=.yaml)
    cat > "$current_dir_state_file" << EOF
hype:
  currentDirectory: "$(pwd)"
EOF
    cmd+=("--state-values-file" "$current_dir_state_file")
    
    debug "Added current directory state values: $(pwd)"
    
    # Clean up current directory state file when done
    # shellcheck disable=SC2064
    trap "rm -f '$current_dir_state_file'" EXIT
    
    # Add state-value-file for StateValueConfigmap resources
    if [[ -f "$HYPE_SECTION_FILE" ]]; then
        local resource_count
        resource_count=$(yq eval '.defaultResources | length' "$HYPE_SECTION_FILE" 2>/dev/null || echo "0")
        
        for (( i=0; i<resource_count; i++ )); do
            local name type
            
            name=$(yq eval ".defaultResources[$i].name" "$HYPE_SECTION_FILE" | sed "s/{{ \.Hype\.Name }}/$hype_name/g")
            type=$(yq eval ".defaultResources[$i].type" "$HYPE_SECTION_FILE")
            
            if [[ "$type" == "StateValueConfigmap" && "$name" != "null" ]]; then
                # Create temporary state values file
                local state_file
                state_file=$(mktemp)
                
                # Extract YAML content directly from ConfigMap data.values key
                if ! kubectl get configmap "$name" -o jsonpath='{.data.values}' > "$state_file" 2>/dev/null; then
                    error "Failed to extract state values from StateValueConfigmap: $name"
                    continue
                fi
                
                # Verify the state file is not empty
                if [[ ! -s "$state_file" ]]; then
                    error "StateValueConfigmap $name contains no values data"
                    continue
                fi
                cmd+=("--state-values-file" "$state_file")
                
                debug "Added state-values-file: $state_file for ConfigMap: $name"
                
                # Debug: Show contents of state values file
                if [[ "$DEBUG" == "true" ]]; then
                    debug "=== STATE VALUES FILE CONTENT ($name) ==="
                    cat "$state_file" >&2
                    debug "=== END STATE VALUES FILE ==="
                fi
                
                # Clean up state file when done
                # shellcheck disable=SC2064
                trap "rm -f '$state_file'" EXIT
            fi
        done
    fi
    
    # Add user-provided arguments
    cmd+=("${helmfile_args[@]}")
    
    debug "Executing: ${cmd[*]}"
    "${cmd[@]}"
}

# Main function
main() {
    if [[ $# -eq 0 ]]; then
        show_help
        exit 1
    fi
    
    case "${1:-}" in
        "--help"|"-h")
            show_help
            ;;
        "--version"|"-v")
            show_version
            ;;
        *)
            if [[ $# -lt 2 ]]; then
                error "Missing required arguments"
                show_help
                exit 1
            fi
            
            local hype_name="$1"
            local command="$2"
            shift 2
            
            # Validate hype name
            if [[ ! "$hype_name" =~ ^[a-zA-Z0-9-]+$ ]]; then
                die "Invalid hype name: $hype_name (only alphanumeric characters and hyphens allowed)"
            fi
            
            check_dependencies
            
            case "$command" in
                "init")
                    cmd_init "$hype_name"
                    ;;
                "deinit")
                    cmd_deinit "$hype_name"
                    ;;
                "check")
                    cmd_check_resources "$hype_name"
                    ;;
                "template")
                    cmd_template "$hype_name"
                    ;;
                "section")
                    cmd_section "$hype_name" "$@"
                    ;;
                "helmfile")
                    cmd_helmfile "$hype_name" "$@"
                    ;;
                "test")
                    if [[ $# -lt 2 ]]; then
                        error "Missing required arguments for test command"
                        error "Usage: hype <hype-name> test template state-value <name>"
                        exit 1
                    fi
                    
                    local subcommand="$1"
                    local subsubcommand="$2"
                    shift 2
                    
                    if [[ "$subcommand" == "template" && "$subsubcommand" == "state-value" ]]; then
                        if [[ $# -lt 1 ]]; then
                            error "State-value name is required"
                            error "Usage: hype <hype-name> test template state-value <name>"
                            exit 1
                        fi
                        cmd_test_template_state_value "$1"
                    else
                        error "Unknown test subcommand: $subcommand $subsubcommand"
                        error "Available: test template state-value <name>"
                        exit 1
                    fi
                    ;;
                *)
                    error "Unknown command: $command"
                    show_help
                    exit 1
                    ;;
            esac
            ;;
    esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi