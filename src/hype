#!/bin/bash

set -euo pipefail

HYPE_VERSION="0.2.0"
HYPE_DEBUG="${HYPE_DEBUG:-false}"

# Debug logging function
debug() {
    if [[ "$HYPE_DEBUG" == "true" ]]; then
        echo "[DEBUG] $*" >&2
    fi
}

# Error logging function
error() {
    echo "[ERROR] $*" >&2
}

# Info logging function
info() {
    echo "[INFO] $*" >&2
}

# Show version information
show_version() {
    echo "HYPE v${HYPE_VERSION}"
    echo "A helmfile wrapper with ConfigMap and Secret management"
}

# Show help information
show_help() {
    cat << EOF
HYPE v${HYPE_VERSION} - A helmfile wrapper with ConfigMap management

USAGE:
    hype <COMMAND> [OPTIONS...]

COMMANDS:
    helmfile [OPTIONS...]    Run helmfile with ConfigMap and Secret management
    --version, -v           Show version information
    --help, -h              Show this help message

HELMFILE COMMAND:
    hype helmfile [HELMFILE_OPTIONS...]
    
    This command wraps helmfile execution with automatic ConfigMap and Secret management.
    It extracts 'templates.hype' objects from helmfile template output,
    creates corresponding ConfigMaps or Secrets based on their type, and injects
    ConfigMap values back into the helmfile execution.
    
    Supported template types:
    - state-value-file: Creates ConfigMaps and injects values (default)
    - secret-defaults: Creates Secrets if they don't exist (no injection)

ENVIRONMENT VARIABLES:
    HYPE_DEBUG              Set to 'true' to enable debug logging

EXAMPLES:
    hype helmfile apply
    hype helmfile diff
    HYPE_DEBUG=true hype helmfile template

For more information about helmfile options, run: helmfile --help
EOF
}

# Validate required dependencies
validate_dependencies() {
    local missing_deps=()
    
    if ! command -v kubectl >/dev/null 2>&1; then
        missing_deps+=("kubectl")
    fi
    
    if ! command -v helmfile >/dev/null 2>&1; then
        missing_deps+=("helmfile")
    fi
    
    if ! command -v yq >/dev/null 2>&1; then
        missing_deps+=("yq")
    fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        error "Missing required dependencies: ${missing_deps[*]}"
        error "Please install the missing dependencies and try again."
        exit 1
    fi
    
    debug "All dependencies validated successfully"
}

# Generate helmfile template and capture output
generate_template() {
    local args=("$@")
    debug "Generating helmfile template with args: ${args[*]}"
    
    # Run helmfile template command and capture output
    local template_output
    if ! template_output=$(helmfile "${args[@]}" template 2>/dev/null); then
        error "Failed to generate helmfile template"
        return 1
    fi
    
    debug "Template generation successful"
    echo "$template_output"
}

# Parse templates.hype objects from YAML output
parse_hype_objects() {
    local yaml_content="$1"
    debug "Parsing YAML content for templates.hype objects"
    
    # Use yq to extract templates.hype objects
    # Look for objects with templates.hype annotation
    local hype_objects
    if ! hype_objects=$(echo "$yaml_content" | yq eval '. | select(.metadata.annotations."templates.hype" != null)' -); then
        debug "No templates.hype objects found or yq parsing failed"
        return 1
    fi
    
    if [[ -z "$hype_objects" || "$hype_objects" == "null" ]]; then
        debug "No templates.hype objects found in template output"
        return 1
    fi
    
    debug "Found templates.hype objects"
    echo "$hype_objects"
}

# Extract template specifications from template output
extract_template_specs() {
    local hype_objects="$1"
    debug "Extracting template specifications from templates.hype objects"
    
    # Extract template names, types, and their corresponding values
    local template_specs
    if ! template_specs=$(echo "$hype_objects" | yq eval '.metadata.annotations."templates.hype" | fromjson' -); then
        error "Failed to parse templates.hype annotation as JSON"
        return 1
    fi
    
    debug "Template specifications extracted successfully"
    echo "$template_specs"
}

# Check if a ConfigMap exists in the current kubectl context
check_configmap_exists() {
    local configmap_name="$1"
    local namespace="${2:-default}"
    debug "Checking if ConfigMap '$configmap_name' exists in namespace '$namespace'"
    
    if kubectl get configmap "$configmap_name" -n "$namespace" >/dev/null 2>&1; then
        debug "ConfigMap '$configmap_name' exists"
        return 0
    else
        debug "ConfigMap '$configmap_name' does not exist"
        return 1
    fi
}

# Check if a Secret exists in the current kubectl context
check_secret_exists() {
    local secret_name="$1"
    local namespace="${2:-default}"
    debug "Checking if Secret '$secret_name' exists in namespace '$namespace'"
    
    if kubectl get secret "$secret_name" -n "$namespace" >/dev/null 2>&1; then
        debug "Secret '$secret_name' exists"
        return 0
    else
        debug "Secret '$secret_name' does not exist"
        return 1
    fi
}

# Create a Secret with the specified data if it doesn't exist
create_secret_if_not_exists() {
    local secret_name="$1"
    local namespace="$2"
    local values_json="$3"
    debug "Creating Secret '$secret_name' in namespace '$namespace' if it doesn't exist"
    
    # Check if Secret already exists
    if check_secret_exists "$secret_name" "$namespace"; then
        info "Secret '$secret_name' already exists in namespace '$namespace', skipping creation"
        return 0
    fi
    
    # Convert JSON values to key-value pairs for kubectl
    local kubectl_args=()
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            kubectl_args+=("--from-literal=$line")
        fi
    done < <(echo "$values_json" | yq eval 'to_entries | .[] | .key + "=" + (.value | tostring)' -)
    
    if [[ ${#kubectl_args[@]} -eq 0 ]]; then
        error "No data found to create Secret '$secret_name'"
        return 1
    fi
    
    debug "Creating Secret with args: kubectl create secret generic $secret_name -n $namespace ${kubectl_args[*]}"
    
    if kubectl create secret generic "$secret_name" -n "$namespace" "${kubectl_args[@]}" >/dev/null 2>&1; then
        info "Created Secret '$secret_name' in namespace '$namespace'"
        return 0
    else
        error "Failed to create Secret '$secret_name'"
        return 1
    fi
}

# Create a ConfigMap with the specified data
create_configmap() {
    local configmap_name="$1"
    local namespace="$2"
    local values_json="$3"
    debug "Creating ConfigMap '$configmap_name' in namespace '$namespace'"
    
    # Convert JSON values to key-value pairs for kubectl
    local kubectl_args=()
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            kubectl_args+=("--from-literal=$line")
        fi
    done < <(echo "$values_json" | yq eval 'to_entries | .[] | .key + "=" + (.value | tostring)' -)
    
    if [[ ${#kubectl_args[@]} -eq 0 ]]; then
        error "No data found to create ConfigMap '$configmap_name'"
        return 1
    fi
    
    debug "Creating ConfigMap with args: kubectl create configmap $configmap_name -n $namespace ${kubectl_args[*]}"
    
    if kubectl create configmap "$configmap_name" -n "$namespace" "${kubectl_args[@]}" >/dev/null 2>&1; then
        info "Created ConfigMap '$configmap_name' in namespace '$namespace'"
        return 0
    else
        error "Failed to create ConfigMap '$configmap_name'"
        return 1
    fi
}

# Manage templates based on specifications (ConfigMaps and Secrets)
manage_templates() {
    local template_specs="$1"
    debug "Managing templates based on specifications"
    
    # Process each template specification
    echo "$template_specs" | yq eval '. | to_entries | .[]' - | while IFS= read -r spec; do
        local template_name
        local namespace
        local values
        local template_type
        
        template_name=$(echo "$spec" | yq eval '.key' -)
        values=$(echo "$spec" | yq eval '.value' -)
        
        # Extract namespace from values if specified, otherwise use default
        namespace=$(echo "$values" | yq eval '.namespace // "default"' -)
        
        # Extract type from values, default to "state-value-file" for backward compatibility
        template_type=$(echo "$values" | yq eval '.type // "state-value-file"' -)
        
        debug "Processing template: $template_name (type: $template_type) in namespace: $namespace"
        
        case "$template_type" in
            "state-value-file")
                # Handle ConfigMap creation (existing behavior)
                if check_configmap_exists "$template_name" "$namespace"; then
                    info "ConfigMap '$template_name' already exists in namespace '$namespace', skipping creation"
                else
                    # Remove type and namespace from values before creating ConfigMap
                    local configmap_values
                    configmap_values=$(echo "$values" | yq eval 'del(.type) | del(.namespace)' -)
                    if ! create_configmap "$template_name" "$namespace" "$configmap_values"; then
                        error "Failed to create ConfigMap '$template_name'"
                        return 1
                    fi
                fi
                ;;
            "secret-defaults")
                # Handle Secret creation (new behavior)
                # Remove type and namespace from values before creating Secret
                local secret_values
                secret_values=$(echo "$values" | yq eval 'del(.type) | del(.namespace)' -)
                if ! create_secret_if_not_exists "$template_name" "$namespace" "$secret_values"; then
                    error "Failed to create Secret '$template_name'"
                    return 1
                fi
                ;;
            *)
                error "Unknown template type '$template_type' for template '$template_name', skipping"
                ;;
        esac
    done
    
    debug "Template management completed successfully"
}

# Manage ConfigMaps based on specifications (kept for backward compatibility)
manage_configmaps() {
    local configmap_specs="$1"
    debug "Managing ConfigMaps based on specifications (legacy function)"
    
    # Delegate to the new manage_templates function
    manage_templates "$configmap_specs"
}

# Extract values from ConfigMap to temporary file
extract_values_from_configmap() {
    local configmap_name="$1"
    local namespace="${2:-default}"
    local temp_file="$3"
    debug "Extracting values from ConfigMap '$configmap_name' to file '$temp_file'"
    
    # Get ConfigMap data and convert to YAML format
    if ! kubectl get configmap "$configmap_name" -n "$namespace" -o yaml | yq eval '.data' - > "$temp_file"; then
        error "Failed to extract values from ConfigMap '$configmap_name'"
        return 1
    fi
    
    debug "Values extracted to '$temp_file'"
}

# Generate temporary value files from ConfigMaps (only for state-value-file type)
generate_value_files() {
    local template_specs="$1"
    local temp_dir="$2"
    debug "Generating temporary value files in '$temp_dir'"
    
    local value_files=()
    
    # Process each template specification
    while IFS= read -r spec; do
        if [[ -z "$spec" || "$spec" == "null" ]]; then
            continue
        fi
        
        local template_name
        local namespace
        local template_type
        
        template_name=$(echo "$spec" | yq eval '.key' -)
        namespace=$(echo "$spec" | yq eval '.value.namespace // "default"' -)
        template_type=$(echo "$spec" | yq eval '.value.type // "state-value-file"' -)
        
        # Only generate value files for state-value-file type (ConfigMaps)
        if [[ "$template_type" == "state-value-file" ]]; then
            local temp_file="$temp_dir/${template_name}.yaml"
            
            if extract_values_from_configmap "$template_name" "$namespace" "$temp_file"; then
                value_files+=("$temp_file")
                debug "Added value file: $temp_file"
            else
                error "Failed to generate value file for ConfigMap '$template_name'"
                return 1
            fi
        else
            debug "Skipping value file generation for template '$template_name' (type: $template_type)"
        fi
    done < <(echo "$template_specs" | yq eval '. | to_entries | .[]' -)
    
    # Return the list of generated files
    printf '%s\n' "${value_files[@]}"
}

# Cleanup temporary files and directory
cleanup_temp_files() {
    local temp_dir="$1"
    debug "Cleaning up temporary directory: $temp_dir"
    
    if [[ -n "$temp_dir" && -d "$temp_dir" ]]; then
        rm -rf "$temp_dir"
        debug "Temporary directory cleaned up"
    fi
}

# Execute helmfile with generated value files
execute_helmfile_with_values() {
    local original_args=("$@")
    
    # Last argument contains the value files (newline separated)
    local value_files_str="${original_args[-1]}"
    original_args=("${original_args[@]:0:${#original_args[@]}-1}")
    
    debug "Executing helmfile with value files"
    
    # Build helmfile command with --state-values-file options
    local helmfile_cmd=("helmfile")
    
    # Add original arguments
    helmfile_cmd+=("${original_args[@]}")
    
    # Add value files as --state-values-file options
    while IFS= read -r value_file; do
        if [[ -n "$value_file" ]]; then
            helmfile_cmd+=("--state-values-file" "$value_file")
            debug "Added value file: $value_file"
        fi
    done <<< "$value_files_str"
    
    info "Executing: ${helmfile_cmd[*]}"
    exec "${helmfile_cmd[@]}"
}

# Main helmfile command handler
cmd_helmfile() {
    debug "Starting helmfile command with args: $*"
    
    # Validate dependencies first
    validate_dependencies
    
    # Store original arguments for final execution
    local original_args=("$@")
    
    # Create temporary directory for value files
    local temp_dir
    temp_dir=$(mktemp -d -t hype-XXXXXX)
    debug "Created temporary directory: $temp_dir"
    
    # Ensure cleanup on exit
    trap 'cleanup_temp_files "$temp_dir"' EXIT
    
    # Generate helmfile template to find templates.hype objects
    info "Generating helmfile template to discover ConfigMap requirements..."
    local template_output
    if ! template_output=$(generate_template "${original_args[@]}"); then
        error "Failed to generate template, falling back to direct helmfile execution"
        exec helmfile "${original_args[@]}"
    fi
    
    # Parse templates.hype objects from the template output
    local hype_objects
    if ! hype_objects=$(parse_hype_objects "$template_output"); then
        info "No templates.hype objects found, executing helmfile directly"
        exec helmfile "${original_args[@]}"
    fi
    
    # Extract template specifications
    local template_specs
    if ! template_specs=$(extract_template_specs "$hype_objects"); then
        error "Failed to extract template specifications, executing helmfile directly"
        exec helmfile "${original_args[@]}"
    fi
    
    debug "Template specifications: $template_specs"
    
    # Manage templates (create ConfigMaps and Secrets if they don't exist)
    info "Managing templates (ConfigMaps and Secrets)..."
    if ! manage_templates "$template_specs"; then
        error "Failed to manage templates, executing helmfile directly"
        exec helmfile "${original_args[@]}"
    fi
    
    # Generate temporary value files from ConfigMaps (only for state-value-file type)
    info "Generating value files from ConfigMaps..."
    local value_files
    if ! value_files=$(generate_value_files "$template_specs" "$temp_dir"); then
        error "Failed to generate value files, executing helmfile directly"
        exec helmfile "${original_args[@]}"
    fi
    
    debug "Generated value files: $value_files"
    
    # Execute helmfile with the generated value files
    info "Executing helmfile with ConfigMap values..."
    execute_helmfile_with_values "${original_args[@]}" "$value_files"
}

# Main function
main() {
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi
    
    case "${1:-}" in
        helmfile)
            shift
            cmd_helmfile "$@"
            ;;
        --version|-v)
            show_version
            ;;
        --help|-h)
            show_help
            ;;
        *)
            error "Unknown command: ${1:-}"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"